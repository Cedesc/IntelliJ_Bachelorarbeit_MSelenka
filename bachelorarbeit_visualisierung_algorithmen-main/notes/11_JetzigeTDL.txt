

12. Weiterschreiben

	- noch sicher reinbringen
		[X10] "1.2 Vergleich von bestehenden Algorithmen" schreiben
		[X3] UML-Klassendiagramm für "2.2 Erweiterbarkeit um weitere Datenstruktur" erstellen
		[X7] "2.1 Vorherige Arbeit" schreiben
		
		[X6] "5.4 Erweiterbarkeit um Baum-Unterarten" anpassen, da anders verstanden
		[X1] Diagramm in "2.2 Erweiterbarkeit um weitere Datenstruktur" einbauen
		[X8] "2.3 Zusammenfassung" schreiben
		[X2] Diagramm ordnen und aufteilen 
		[_0, X6] ALLE Einleitungstexte schreiben (zwingend, aber nur 1-2 Sätze was davor gemacht wurde und was jetzt gemacht wird)
			- [X1] 2 Architektur
			- [X1] 3 Überarbeitungen am bestehenden Code
			- [X1] 4 Datenstruktur Baum
			- [X1] 5 Umsetzung Baum im Programm
			- [X1] 6 Erweiterung um visuelle Funktionalitäten
			- [X1] 7 Zukünftige Arbeit
		[X10] um ganzen kleinen ToDos kümmern (die nicht bzgl latex)
		[_0, X18] ALLE Zusammenfassungstexte schreiben (nicht zwingend, nur wenn es sich anbietet)
			- [X3] 2 Architektur
			- [X3] 3 Überarbeitungen am bestehenden Code
			- [X3] 4 Datenstruktur Baum
			- [X3] 5 Umsetzung Baum im Programm
			- [X3] 6 Erweiterung um visuelle Funktionalitäten
			- [X3] 7 Zukünftige Arbeit
		[_0 , X41] Texte überarbeiten (41 Texte)
			- [X1] Abstract
			- 1 Einleitung
				- [X1] Anfang
				- [X1] 1.1 Motivation
				- [X1] 1.2 Vergleich von ähnlichen Programmen
				- [X1] 1.3 Zielsetzung
				- [X1] 1.4 Strukturierung des Inhalts der Arbeit
			- 2 Architektur
				- [X1] 2.1 Vorherige Arbeit
				- [X1] 2.2 Erweiterbarkeit um weitere Datenstruktur (am Beispiel von Bäumen)
				- [X1] 2.3 Erweiterung der Architektur
				- [X1] 2.4 Zusammenfassung
			- 3 Überarbeitung des bestehenden Codes
				- [X1] Anfang
				- [X1] 3.1 Refaktorierung und Kommentare
				- [X1] 3.2 ArrayList
				- [X1] 3.3 Komplette Darstellung
				- [X1] 3.4 Config Datei
			- 4 Datenstruktur Baum
				- [X1] Anfang
				- [X1] 4.1 Terminologie
				- [X1] 4.2 Definition
				- [X1] 4.3 Speicherung von Bäumen
				- [X1] 4.4 Atomare Operationen
				- [X1] 4.5 Anwendung von Bäumen
			- 5 Umsetzung Baum im Programm
				- [X1] Anfang
				- [X1] 5.1 Problematik
				- [X1] 5.2 Visualisierungsalgorithmus
				- [X1] 5.3 Implementierung
				- [X1] 5.4 Erweiterbarkeit um Baum-Unterarten
			- 6 Erweiterung um visuelle Funktionalitäten
				- [X1] Anfang
				- [X1] 6.1 Animationen
				- [X1] 6.2 Erweiterbarkeit um weitere Animationen
				- 6.3 Konkrete Animationen
					- [X1] 6.3.1 Animationen in ArrayList
					- [X1] 6.3.2 Animationen in Bäumen
				- [X1] 6.4 Zoomen und Bewegen
				- [X1] 6.5 Zusammenfassung
			- 7 Zukünftige Arbeit
				- [X1] Anfang
				- [X1] 7.1 Bestehende Probleme
				- [X1] 7.2 Ausblick
			- 8 Zusammenfassung
				- [X1] Inhalt
		[X0] Mit IntelliJ auf Rechtschreibung prüfen
		


		
		[_10] in latex einbringen (dabei auch um die latex bezogenen ToDos in den Texten kümmern)
			[X] Auflistungen korrekt darstellen lassen
			[X] Matheumgebungen richtig setzen
			[X] Grafiken korrekt trennen und als einzelne Grafiken einbringen (aufpassen, dass alles leserlich ist, ggf zusammenrücken)
				[X] sequenzdiagramm
				[X] uml erweiterung um bäume
				[X] uml erweiterung um animationen
				[X] bilder von visualisierten baum (TreeDemo)
			[X] Anführungszeichen korrekt setzen
			[X] Text kursiv oder in schreibmaschinenschrift setzen? Was davon? Was anderes? => Beides!
			[X] Verweise auf andere Kapitel einbringen
			[X] Wie mach ich das mit dem Quellenverweis auf die BA von Selenka?
			[X] Info-Datenstruktur kursiv oder in Anführungszeichen? => nichts
			[X] Website-Verweise einbringen
			[ ] Quellenverweise einbringen
			[ ] Vernünftige Absätze einbringen
			[ ] Grafiken so anbringen, dass sie richtig zusammen angezeigt werden
			[ ] Größen der Grafiken anpassen
			[ ] Fußnoten ?
			[ ] Grafiken zu Anhang hinzufügen
			[ ] nach Dingen suchen
				- PLATZHALTER
				- Anführungszeichen
			[ ] "Listing" zu "Codeabschnitt" umbenennen
			[ ] in bibliografy die zwei defaults löschen
		[_0] Alles an "ConfigReader" raushauen
		[_12 , X6] Sachen aus "noch vielleicht einbringen"
		[_0] Leute Korrekturlesen lassen
			- einmal für Rechtschreibung
				- Dinah ?
				- Selina ?
				- Alice ?
			- einmal für Inhaltliches
				- Mateusz ? Bisschen zu spät i guess, wegen seiner BA
			- Gliederung
				- 1
					- Dinah
				- 2
				- 3
				- 4
				- 5
				- 6
				- 7
					- Robin
				- 8
					- Robin
		[_0] Fragen an inhaltlichen Korrekturleser
			- nach lesen von Kapitel 4 (Datenstruktur Baum) und 5.3 (Umsetzung.Implementierung), was bleiben noch für Fragen offen bzgl Bäume?
		
		
	- noch vielleicht reinbringen
		[X2] Screenshots aus Programm (also der ausgeführten Anwendung) einbauen ?? (wenn dann zoomen plus eventuell bewegen)
		[X2] "5.? Neue Struktur der Architektur" aufsplitten auf die beiden Sachen davor?
		[X2] UML Sequenz Diagramm zu controller.ExecuteAlgorithmController.initialize() (wegen SceneGestures und NodeGestures um zu sehen, wann diese mit reinspielen) erstellen??? Oder zu controller.ExecuteAlgorithmController.updateVisualization()???
		[X0] Selbstgemachte Grafik, in der an einem Baum die ganzen Sachen beschriftet ist????? Eher nicht
		- UML Sequenzdiagramm:
			[_4] Sequenzdiagramm für visualisierung mit drawBefehl für Bäume ?
				- Vergleich zu alter Methode
				- wohin? (5.1 / 5.2)
				- zu beachten: man muss auch was dazu schreiben
		[_2] Anhang wie?
		[_2] Alle Wörter, die abkürzbar sind, einheitlich abkürzen oder nicht abkürzen: ggf., bspw., z.B., u.a.,...
		[_4] Einleitungssätze auch für (alle) Unterkapitel??
		[_?] In 7.2 nice to have stuff reinbringen ??? 
			"Weniger wichtig, aber mögliche punkte, wären:"
				- Button zum Zurücksetzen des Zooms 
				- Button zum Zurücksetzen der Translation
				- Mehr Optionen bei complete visualization:
					- Button um direkt zum Endergebnis zu springen
					- Button um Pause zu drücken
					- automatisches Skalieren bei complete visualization (bei Bäumen gut zu beobachten)
				- Animationen schneller oder langsamer zur Laufzeit machen können.
		[_?] Folgendes irgendwie einbringen?? "Bäume gehören zu den wichtigsten in der Informatik auftretenden Datenstrukturen. Entscheidungsbäume, Syntaxbäume, Ableitungsbäume, Kodebäume, spannende Bäume, baumartig strukturierte Suchräume, Suchbäume und viele andere belegen die Allgegenwart von Bäumen." [Ottmann 259 (278) Kapitel 5 Bäume]}
		
	- geschriebenes überarbeiten
	- verlinkungen zu nutzungen der terminologie begriffe
	- überall "ich" mit "wir" und "man" mit passivem ersetzen
	- Bei Websites auch letzter Zugriff angeben
	- Klassen in Text erwähnen mit dieser Schriftart aus der anderen BA
	- Alle "PLATZHALTER" rausschmeißen
	- alle funktionen, klassen etc im text in anderer schriftweise schreiben und ohne anführungszeichen
	- ToDo's:
		- Was muss ich beim abgeben beachten?
			- ausgedruckt im studienbüro abgeben?
			- noch irgendwas bzgl dem code tun? Reicht es, dass der in gitlab ist? Muss ich noch explizit drauf verweisen, dass der dort vorliegt?
	- Achtung: Bei "4.? Algorithmus zum Baum visualisieren" wurde der erste Absatz rausgenommen, was ich auch bei Latex nochmal anpassen sollte
		- generell, wenn ich alles (bzw das meiste) geschrieben habe, sollte ich aus den txt Dateien sicherheitshalber nochmal alles neu einsetzen




CHECK! 20. README mit meinem Zeug erweitern
	CHECK! - Bäume hinzufügen
	CHECK! - ArrayList hinzufügen
	CHECK! - bei gitlab hochladen


21. Animationen 
	- Reihenfolge optional ändern
		- zuerst Animation, dann draw
		- beides möglich machen
	- Schwierigkeit: Kanten
		- verschwindet, dann werden Knoten bewegt und taucht an der richtigen Stelle wieder auf
	- Fortschritt:
		- fertig:
			createTree, addLeaf, changeValue, getIndexByValue, getNodeByIndex
		- noch zu erledigen:
			deleteTree, deleteLeaf, changeParent
	- automatisches justieren des Baums (?)
		- lieber reihenfolge von updateView ändern (im onFinished event oder vor befehlen zeichnen)
	- man braucht nach dem draw befehl die Koordinaten von zuvor
		- deepCopy vom Baum erstellen um die Positionen der Knoten zu haben und das nutzt man als Referenz für die Animationen???
	- interagieren zwischen zwei Instanzen von Datenstrukturen
        - Beispiel: Ein Element wird von einem Array in ein freies Feld eines anderen Arrays geschoben
			- Versucht mit Baum und Variable, was aber nicht geklappt hat, da ich nicht die korrekten Koordinaten gefunden habe
	- automatisch ausgeführte get Animationen bei gewissen Befehlen einfügen (?)
	
	
22. Bäume verbessern
    Weiteres:
		- Wurzel darf nicht rightBrother haben
		- beim visualisieren bewegt sich der scheiß automatisch nach rechts bzw links
			- immer wieder richtig rücken?
			- liegts am scaling?
		- skip in getNodeByIndex ist sus
			- Scheinbar nur bei node not found
			- bei mehreren node not found wird nur erster geskippt, scheinbar auch wenn zwischen denen node not found noch andere befehle liegen
			- (fast) nur wenn das programm einmal komplett durchgelaufen ist und dann auf repeat visualization
			- kommt scheinbar auch bei anderen null transitions vor (create variable)
				- kommt scheinbar bei ALLEN befehlen ohne animation vor



CHECK! 31. Config
	- richtige Config statt Java Klasse nutzen
		https://stackoverflow.com/questions/16273174/how-to-read-a-configuration-file-in-java
		


41. Work off ToDo's
















Wenn-zu-viel-Zeit-TDL:

	11. Refactoring
		- wiederholtes "if visualization != null..." in den visualization klassen (?) zu einer funktion

	12. Animationen
		- deleteArrayList klappt nicht (wahrscheinlich auch deleteElement nicht), da die Sachen zuerst gelöscht werden, bevor die Animationen durchlaufen können
			- Lösungsvorschlag:
				Idee 1: das tatsächliche Löschen als atEnd Event (oder wie auch immer) der Animation aufrufen
				Idee 2: irgendwie ein Event bauen, das beim Ende der Animation aktiviert wird und dabei das Element löscht
					- Problem bei beiden: könnte leicht bei zu schnellen Eingaben zu Fehlern kommen. Vielleicht kann ich es wirklich rein visuell halten?
		- animation für "get" funktionen erstellen
	
	21. Zoomen
		- Button zum Zurücksetzen des Zooms (erst mit dem "TerminateButton" testen)
	
	22. Dragging
		- Button zum Zurücksetzen der Translation
		
	23. Complete Visualization
		- Button um direkt zum Endergebnis zu springen
		- Button um Pause zu drücken
		- automatisches Skalieren bei complete visualization (bei Bäumen gut zu beobachten)
	
	24. Animationen
		- Animationen schneller oder langsamer zur Laufzeit machen können.

	41. ScrollPane entfernen und stattdessen anderen Knoten, zb normales Pane, welcher aber nur die feste Größe als Fenster anzeigt
		- Lösung: (etwas unschön, da weiterhin ScrollPane)
			<ScrollPane  minWidth="500" fx:id="algVisScrollPane"
						 hmax="0" vmax="0" hbarPolicy="NEVER" vbarPolicy="NEVER">
	






Gelöscht aus Kapitel 6 Erweiterung um visuelle Funktionalitäten 6.1 Animationen nach "% // Eigene Umsetzung", da eig bereits in 2 Architektur 2.3 Erweiterung der Architektur vorhanden

% // auf die Ordnerstruktur bezogen auf die Animationen eingehen und schreiben wo die erstellt und ausgeführt werden
	So wie es für jede Datenstruktur eine eigene Klasse für die Visualisierung gibt, wurde hier ebenso für jede Datenstruktur eine Klasse zum Erstellen der jeweiligen Animationen hinzugefügt. Der Vorgang ist in PLATZHALTER \todo{Abbildung 1} anhand eines UML-Sequenzdiagramms am Beispiel des "addLeaf"-Befehls der Bäume verdeutlich. Wird der Befehl in der Info-Datenstruktur \todo{Auf eine Definition verweisen?} InfoTree aufgerufen, so wird zunächst durch einen Aufruf der addLeaf-Methode des von InfoTree gespeicherten "MyTree"s, die Änderung der Daten ausgeführt. Konkret bedeutet dies in dem Fall das Hinzufügen des Blatts, das als newLeaf abgespeichert wird. Nach der Manipulierung der Daten wird die Visualisierungsklasse, hier TreeVisualization, aufgerufen. Dabei werden zunächst visuelle Elemente hinzugefügt, gelöscht oder geändert und daraufhin die passende Animation dazu erstellt. Im Beispiel bedeutet das erst einen Aufruf von drawAllTrees, wodurch anhand der Daten der Bäume, all diese neu erstellt werden und danach die Erstellung der Animation mithilfe der forAddLeaf-Methode. Diese Trennung zwischen Visualisierung und Erstellung der Animationen sorgt für eine bessere Wartbarkeit des Codes, da es sowohl klarer ist, welche Codeabschnitte was bewirken, als auch die Funktionen kürzer und übersichtlicher gehalten werden können.
