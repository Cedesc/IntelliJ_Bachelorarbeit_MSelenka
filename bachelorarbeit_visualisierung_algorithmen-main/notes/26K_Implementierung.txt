

Teil der Gliederung:
	6 Implementierung 25 (6) (mehr)
		6.1 Ablauf und Organisation 25 (1)
		6.2 Änderungen am bestehenden Code 26 (2)
		    - Auch auf Bugfixes im bestehenden Code eingehen
		6.3 Herausforderungen und Umsetzung 28 (2)
		6.4 Zusammenfassung 30 (1)



Was ich reinbringen kann:


Kapitel:

6.2 Änderungen am bestehenden Code
	{Sequenzdiagramm einfügen?}
	{"Config" überarbeiten? Auch auf ConfigReader eingehen oder das so lassen? Sollte ich irgendwo in der Arbeit ConfigReader erwähnen, sollte ich das hier aufgreifen}

	// Refactoring und Kommentare
	Fast alle Dateien wurden geringfügig geändert. Das kommt daher, dass viele Rechtschreibfehler korrigiert, teilweise Kommentare hinzugefügt oder auch Dateien oder Funktionen umbenannt wurden. So wurde zum Beispiel zur besseren Verständlichkeit die Methode "startVisualization" der Klasse "ParentViewModel" zu "startCompleteVisualization" umbenannt, da die Methode an sich die komplette Visualisierung statt der Schritt-für-Schritt Visualisierung startet, es mit dem vorherigen Namen aber auch wie eine allgemeinere, für die Schritt-für-Schritt Visualisierung wichtige, Funktionalität wirken konnte.
	Auch wurden an sehr vielen Stellen Kleinigkeiten geändert, die zuvor in der Entwicklungsumgebung Warnungen hervorgerufen haben. So wurden unter anderem rohe Verwendungen parametrisierter Klassen korrigiert oder auch ungenutzte Auflistungen von Fehlern in der "throws list" der jeweiligen Methode entfernt.
	Da in der Klasse "ParentViewModel" ein großer Teil des Codes für die Methoden "exeNextCommand", "exePreviousCommand" und "startCompleteVisualization" sehr ähnlich war, wurde dieser als eigene Methode mit dem Namen "exeCommand" ausgelagert. Innerhalb der drei genannten Methoden hat sich so die Anzahl der Zeilen von jeweils 60 auf jeweils maximal 10 geändert. Somit ist der Bereich des Codes nun deutlich übersichtlicher. Weiterhin auch besser anpassbar, da durch das Auslagern der Methode nur an einer Stelle eventuelle Änderungen getätigt werden müssen, statt wie zuvor darauf achten zu müssen, dass man an allen drei Stellen den Code umschreibt.
	
	// Komplette Visualisierung
	Der Code und auch das Konzept für die komplette Visualisierung wurde stark überarbeitet. Zuvor war es nicht möglich in der kompletten Visualisierung die einzelnen Schritte nachzuverfolgen, stattdessen sollte nach gewisser Wartezeit direkt das Endergebnis angezeigt werden. Durch einen Fehler konnte es aber zu falschen Ergebnissen kommen, da statt allen Befehlen nur einer wiederholt abgespielt wurde. Nun kann die Anwendung nach dem Auswählen der kompletten Visualisierung die Befehle zeitversetzt oder auch mit ihren Animationen nacheinander abspielen, sodass der Algorithmus selbständig nach und nach ausgeführt wird und es für den Nutzer wie eine Aufzeichnung wirkt.
	Um dies zu erreichen wurden zunächst Animationen (und auch "leere Animationen", in denen sich nichts bewegt, sondern einfach nur abgewartet wird) hinzugefügt. Alle Animationen wollten dabei allerdings zeitgleich starten. Mit dem Hintergrund, dass die Animationen korrekt zeitgleich starten sollten, wurden daraufhin die Animationen stattdessen gespeichert, statt sofort abspielen zu lassen und daraufhin nach und nach abgespielt. Dadurch wurden zwar die Animationen korrekt nacheinander abgespielt, jedoch gab es ein anderes Problem: Zum Start der ersten Animation wurden bereits alle Elemente erstellt, sodass schon zum Start direkt alle Elemente, oft an unsinnigen Positionen, sichtbar waren. 
	Eine Möglichkeit, um das zu beheben, wäre alle Elemente, die derzeit nicht angezeigt werden, unsichtbar zu stellen. Geht man diesen Lösungspfad, kann die zukünftige Erstellung von Animationen jedoch verkompliziert werden. Zudem kommt es schnell zu Schwierigkeiten, da die unsichtbaren Elemente dennoch vorhanden sind. Beispiel dafür wäre das korrekte Einfügen an eine bestimmte Position in einer Arraylist. Hat man hier unsichtbare Elemente, muss man genau schauen, wo das tatsächliche Element landen wird.
	Ein anderer betrachteter Lösungsansatz war, dass zwischen den einzelnen Befehlsausführungen das Programm die entsprechende Zeit wartet, bis es fortfährt. Hier müsste man allerdings zuerst eine gute Methode finden, die zwar das Programm warten lässt, gleichzeitig aber weitere Nutzereingaben, wie das Abbrechen der Visualisierung erlaubt. Außerdem könnte es unhandlich werden die tatsächlichen Wartezeiten einzubauen und es wäre gegebenenfalls auch vom Gerät abhängig, wie schnell dieses die Berechnungen durchführen kann und ob sich in der Praxis nicht vielleicht die Wartezeit von der Zeit der Animation unterscheidet.
	Die letztlich implementierte Lösung geht wie folgt vor: 
		1. Der momentane Befehl wird ausgeführt, wodurch auch die Animation dazu erstellt, aber noch nicht gestartet, wird.
		2. Die Funktion zum Starten des nächsten Befehls wird als "onFinishedEvent" zu der Animation hinzugefügt, welches bewirkt, dass der hinzugefügte Befehl dann gestartet wird, wenn die Animation fertig ist.
		3. Die momentane Animation wird gestartet.
		4. Nach der Animation wird durch das Event der nächste Befehl ausgeführt und die Schritte wiederholen sich.
		\todo{Hier Sequenzdiagramm?}
	Nachteile dieser Herangehensweise sind, dass es unintuitiv erscheint und dass gewisse Klassen dabei mehr ineinander verzahnt sind. So wird in der derzeitigen Implementierung vom "ExecuteAlgorithmController" auf das "ParentViewModel" zugegriffen, obwohl letzteres an sich höher gestellt sein sollte. Dies kann die Verständlichkeit des Codes beeinträchtigen, weshalb eine ausführliche Dokumentierung dazu angestrebt wurde. Man könnte auch sagen, ein Nachteil wäre, dass jeder Befehl eine Animation braucht, da ansonsten natürlich nicht der nächste Befehl ausgeführt werden könnte. Allerdings lässt sich das einfach mit einem Platzhalter beheben. Dies ist auch so umgesetzt, durch eine Überladung der Methode "generateNode" in den Visualisierungsklassen. Wird keine Animation übergeben, so wird eine "leere Animation" erstellt. 
	Auf der Seite der Vorteile wäre zunächst, dass der Nutzer ohne Probleme Eingaben während den Animationen tätigen kann. Weiterhin ist man von keinem anderen Timer abhängig, wodurch möglicherweise unterschiedliche Zeiten vermieden werden. Die Funktionalität hängt auch nicht von der Länge der Animationen ab, sodass sie beliebig lang und natürlich auch unterschiedlich lang sein können. Mit dieser Lösung bewegt sich nun die Hervorhebung des ausgewählten Befehls in der Befehlsliste mit Befehl zu Befehl mit, was mit der Lösung durch das unsichtbar stellen nicht so einfach möglich gewesen wäre. Trotz des etwas befremdlichen Ansatzes, mussten für die Umsetzung nur kleine Änderungen an bestehendem Code getätigt werden. Nachdem die Idee und das Konzept für diese Art der kompletten Visualisierung aufkam, gab es in der letztlichen Implementierung keine größeren Schwierigkeiten und es brauchte, im Vergleich zu anderen Überlegungen zur Lösung des Problems, deutlich weniger Zeilen im Code.

	// "Config"
	Da es gewisse Parameter im Code gibt, die je nach Zweck angepasst werden sollten, wurde eine "Config"-Datei hinzugefügt, die dafür sorgt, dass man die wichtigsten Parameter auf einen Blick sieht und auch leicht anpassen kann. So ist nun der Ordnerpfad zu den Algorithmen in der Datei abgespeichert, sodass man diesen nicht beschwerlich raussuchen muss, möchte man die Anwendung von einem anderen Gerät starten. Weiterhin sind die Startwerte für die Fensterbreite, Fensterhöhe und die Option für Vollbild des Fensters hierin abgespeichert. Auch der Referenzwert für die Länge aller Animationen und sowohl die maximale als auch die minimale mögliche Skalierung für den Zoom kann hier geändert werden.



6.? Erweiterbarkeit um weitere Datenstruktur
	{Beim Teil der abzuändernden Dateien auch noch Beispielcode aus den beiden Dateien einfügen? Wär nicht viel im Vergleich zum Beispielcode einer ganzen Datenstruktur...}
	
	// Hinzuzufügende Dateien
	Um aufzuzeigen, wie eine weitere Datenstruktur grundsätzlich hinzuzufügen ist, wird nachfolgend erläutert, welche Dateien man hinzufügen sollte und welche Dateien angepasst werden müssen. Angenommen man fügt eine Datenstruktur mit dem Namen "XY" hinzu und hält die vorhandenen Namenskonventionen für die Dateien bei, so müsste man folgende Dateien hinzufügen:
			datastructures.XY, 
			datastructures.InfoXY, 
			builders.XYBuilder,
			commands.XYCommands.XYCommand, 
			visualization.XYVisualization,
			visualization.animationCreation.XYAnimation,
			Algorithms.XYAlgorithm
	Zu beachten ist hierbei, dass für jeden grundlegenden Befehl der Datenstruktur eine eigene Klasse, die von "XYCommand" erbt, im Ordner "commands" erstellt werden muss. So könnte noch, analog zu den bereits vorhandenen Datenstrukturen, bspw. "commands.CreateXY" oder "commands.InsertElementXY" hinzugefügt werden. 
	Sollen mehrere Algorithmen zur Klasse auswählbar und vorführbar sein, so ist auch hier für jeden dieser eine Klasse in "Algorithms" hinzuzufügen. Neben der bereits gelisteten Datei "Algorithms.XYAlgorithm", wären Beispiele hierfür "Algorithms.SortXYAlgorithm" oder "Algorithms.SearchXYAlgorithm".
	
	// Abzuändernde Dateien
	Was der Wartbarkeit des Programms sehr zugute kommt ist, dass beim Hinzufügen einer Datenstruktur nur zwei bereits existierende Dateien tatsächlich abgeändert werden müssen und das auch nur in geringem Maße. Diese beiden Dateien sind:
		abstractAlgorithm.AbstractAlgorithm
		model.ParentViewModel
	So ist in "AbstractAlgorithm" ein Attribut und eine Methode hinzuzufügen. Das Attribut ist der Builder, den man bereits als "builders.XYBuilder" erstellt hat. Dieses Attribut wird in der hinzuzufügenden Methode "create_XY" verwendet, welche dann wiederum in den von "AbstractAlgorithm" erbenden Algorithmen-Klassen genutzt werden kann. Soll die Datenstruktur mehr als eine Möglichkeit haben eine neue Instanz in den Algorithmen erzeugen zu können, so müssen gegebenenfalls weitere Methoden erstellt werden. 
	In "ParentViewModel" muss ein Attribut hinzugefügt und zwei Methoden erweitert werden. Hinzugefügt werden muss die in "visualization.XYVisualization" abgespeicherte Klasse zur Visualisierung. Bei den zu erweiternden Methoden sollten auch nur wenige Zeilen erforderlich sein. So muss "exeCommand" zusätzlich den Fall "XYCommand" abdecken und "resetVisualization" auch die als Attribut abgespeicherte Visualisierung für XY zurücksetzen.


6.? Bestehende Probleme
	
	// Allgemein
	Wie bereits gezeigt, wurde die Anwendung um einige Funktionalitäten erweitert. Jedoch bleiben zwei größere, bislang ungelöste Probleme bestehen. Diese wollen wir in diesem Unterkapitel aufzeigen und dazu mögliche Lösungsansätze präsentieren. 
	
	// Animationen für Löschoperationen
	Das erste Problem wurde durch das Hinzufügen der Animationen ersichtlich. Dabei handelt es sich um die Animationen jeglicher Löschoperationen. Die Problematik besteht darin, dass zum momentanen Stand zuerst die im tatsächliche Instanz der Datenstruktur geändert wird und daraufhin die visuellen Elemente erzeugt und die Animation erstellt wird. Soll nun eine Animation für eine Operation, die mindestens ein Element aus der Datenstruktur löscht, erstellt werden, ist es nicht möglich die originale Visualisierung des gelöschten Elements zu nutzen, da dieses Element zuvor gelöscht wurde. 
	// naiv umdrehen - verschiebt das Problem nur
	Zwar ist es möglich die Reihenfolge umzudrehen, bedeutet es würde zuerst visualisiert und animiert und daraufhin die im Hintergrund liegende Datenstruktur geändert werden, jedoch besteht dann ein analoges Problem bezüglich aller Operationen, die Elemente hinzufügen. 
	// immer neue visuelle Elemente erzeugen
	Ein erster tatsächlicher Lösungsansatz ist das gelöschte Element visuell neu zu erzeugen. Das heißt, das gelöschte Element wird im Hintergrund abgespeichert und übergeben, sodass von diesem eine visuelle Darstellung erzeugt werden kann. Dieser Ansatz stellt sich allerdings als umständlich und fehleranfällig heraus, da visuelle Abbilder etlicher Elemente erzeugt, richtig platziert und auch wieder richtig gelöscht werden müssen. Dennoch könnte diese Idee mit geschickter Umsetzung das Problem beheben ohne zu starke Nachteile aufzuweisen. 
	// sowohl vor als auch nach visualisierung animation zulassen
	Ein eventuell besserer Lösungsansatz wäre, dass nicht, wie oben beschrieben vor der Manipulierung der Datenstruktur die Visualisierung ansetzt, sondern diese sowohl davor als auch danach aufgerufen werden kann. Dies kann von Operation zu Operation einzeln entschieden werden, indem die Reihenfolge der Funktionsaufrufe in der Info-Datenstruktur getauscht wird. In {Abbildung 1} \todo{auf richtige Abbildung verweisen} ist dies anhand der fiktiven Datenstruktur "XY" verdeutlicht. Während in "addElement" zuerst das Element hinzugefügt und daraufhin erst die Visualisierung ausgeführt wird, so wie es im vorhandenen Programmcode derzeit bei allen Operationen der Fall ist, wird dies bei "deleteElement" durch einfach vertauschen der Zeilen andersrum ausgeführt. Für zukünftige potenziell komplexere Operationen könnte dies noch nicht ausreichend sein, da Operation vorstellbar sind, die bestenfalls sowohl vor als auch nach der tatsächlichen Änderung eine Visualisierung benötigen. In dem Fall wäre es möglich die Funktion wie in {Abbildung 2} \todo{auf richtige Abbildung verweisen} gezeigt zu schreiben. Hier sind zwei Visualisierungsfunktionen vorhanden, eine zum Ausführen vor der Änderungen, eine für nach der Änderung. Zu bemerken ist dabei, dass auf die tatsächliche Abfolge der Befehle in Kombination mit den Animationen zu achten ist, da die Befehle in der kompletten Visualisierung, wie in {Kapitel XY} \todo{auf richtiges Kapitel verweisen} beschrieben, durch Events der Animationen ausgelöst werden. Sind dementsprechende Änderungen allerdings vorgenommen worden, wäre nicht nur das Problem der Animationen für Löschoperationen gelöst, sondern zudem eine gute Grundlage für die Visualisierung zukünftig hinzugefügter Operationen geschaffen.
	
	// Justierung des Baums
	Das zweite Problem bezieht sich auf die Visualisierung der implementierten Bäume. Derzeit wird noch, wenn z.B. ein Knoten zum Baum hinzugefügt wird, der Knoten animiert hinzugefügt, der Rest des Baums allerdings auf einen Schlag positioniert. Dies verfehlt das eigentliche Ziel der Implementierung von Animationen. Zwar sind die einzelnen Schritte deutlich nachvollziehbarer, allerdings kann die Verständlichkeit vorallem bei größeren Neupositionierungen stark darunter leiden. Besser wäre es, würden diese Neupositionierungen der Knoten nicht in einem Schritt, sondern durch Bewegungsanimationen von Start- zum Zielpunkt ausgeführt werden.
	// Neupositionierung umsetzen
	Dies gut umzusetzen, kann sich als schwierig herausstellen. Ein erster Ansatz wäre es mithilfe der vorherigen und letztendlichen Koordinaten aller Knoten für jeden einzelnen Knoten eine Translationsanimation zu erstellen. Um alle diese Koordinaten zu speichern, ist es möglich vor der Ausführung der Operation zuerst alle Koordinaten abzuspeichern, dann die Operation auszuführen, die Koordinaten der Knoten neu zu berechnen und diese, vor dem Erstellen der Visualisierung, zusätzlich abspeichern. Die Erstellung der einzelnen Animationen ist hierbei nicht mehr schwierig. Allerdings darf die Änderung durch die getätigte Operation, wie bspw. ein geändertes Element, zum Start der Visualisierung noch nicht sichtbar sein. Entweder es wird hierfür eine generelle Lösung oder die Visualisierung muss umständlich bei jedem Befehl individuell manipuliert werden. Eine naive generelle Lösung wäre die Operation zunächst rückgängig machen und daraufhin nochmal aufrufen. Dies erscheint jedoch als umständlich und sollte, wenn möglich, vermieden werden. Abseits dessen bleiben die Kanten des Baums weiterhin ein Problem, da sie trotz unterschiedlich weiten Bewegungen von Elternknoten und Kindknoten passend mitbewegt werden sollten. 
	// Mit vorherig beschriebenen "Reihenfolge Manipulierung Visualisierung" verbinden
	Wurde eine Umsetzung für das Justieren des Baums gefunden und die Aufrufe der "Info-Datenstruktur" wie zuvor beschrieben angepasst, sodass sowohl vor als auch nach der Änderung der Datenstruktur eine Visualisierung aufrufbar ist, so wäre es möglich den Baum mit der ersten Animation zunächst passend zu justieren und danach mit einer zweiten Animation die Operation, wie das Hinzufügen eines Blatts, zu visualisieren.




\todo{write caption and label}
\begin{lstlisting}[language=Java, caption={}\label{Abbildung 1}]
	public class InfoXY {
		// ...
		public void addElement() {
			// ...
			// add the element
			this.xyContent.addElement();
			// visualize the command
			if (this.xyVisualization != null) {
				this.xyVisualization.addElementVisualization(this);
			}
		}
		public void deleteElement() {
			// ...
			// visualize the command
			if (this.xyVisualization != null) {
				this.xyVisualization.deleteElementVisualization();
			}
			// delete the element
			this.xyContent.deleteElement();
		}
		// ...
	}
\end{lstlisting}

\todo{write caption and label}
\begin{lstlisting}[language=Java, caption={}\label{Abbildung 2}]
	public class InfoXY {
		// ...
		public void complexOperation() {
			// visualize the command
			if (this.xyVisualization != null) {
				this.xyVisualization.complexVisualizationBefore();
			}
			// execute the command
			this.xyContent.complex();
			// visualize the command
			if (this.xyVisualization != null) {
				this.xyVisualization.complexVisualizationAfter();
			}
		}
		// ...
	}
\end{lstlisting}
