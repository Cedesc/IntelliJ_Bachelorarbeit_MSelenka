

Erledigt:
	Samstag: 
		- Rausfinden was es generell für Operationen gibt
		- Beim ScrollPane in der fxml Datei einen Kommentar schreiben der erklärt, warum es ein ScrollPane ist
	Sonntag: 
		- In Literatur schauen, ob da z.B. in Algorithmen vermeintlich atomare Operationen weiter aufgebrochen werden (z.B. das rotieren mit anderen Operationen dargestellt werden kann)

Detaillierte TDL:
	Montag:
		- Visualisierung zu den einzelnen Operationen überlegen
	Dienstag: 
		Fehler bei zu schnellen Eingaben
		- Rausfinden wo da die Grenzen sind
		- Rausfinden, wie ich es vorzeigen kann, ohne dass es Fehler gibt
	Mittwoch:
		- Aufbereiten, also vernünftig aufschreiben
	




Operationen:
	
	- Nach Element suchen (also quasi get) [2] [3]
		- input: Value zuSuchenderWert Node wurzelknoten
		- output: Node gesuchterKnoten
		- Weiteres:
			- Aber auf welche Weise? Tiefen- oder Breitensuche?
		- Visualisierung:
			Ideen:
				1. Jedes Element, das betrachtet wird, pulsiert kurz bis das gesuchte Element gefunden wird, dieses pulsiert zb nochmals stärker
				2. Das gesuchte Element pulsiert
	- Element an bestimmter Stelle hinzufügen [2] [3]
		- input: Node elternknoten , Int wievieltesKind , Node neuerKnoten
		- output: - / Boolean
		- Visualisierung: 
			Nach oben Reinfaden des Elements 
	- Teilbaum löschen [1]
		- input: Node zuLöschenderKnoten
		- output: - / Boolean
		- Visualisierung:
			Nach unten Rausfaden
	- Einfache Rotation (sowohl links als auch rechts)
		- input: Node zuRotierenderKnoten (dieser und der Elternknoten werden genutzt)
		- output: - / Boolean
		- Visualisierung:
			Zuerst wird der obere Knoten an die richtige Stelle verschoben, dann geht der Teilbaum, der noch am unteren Knoten hängt, zum verschobenen Knoten und letztlich rückt der zuerst untere Knoten nach
	- Get Wurzel (nicht schon automatisch da?) [1]
		- input: -
		- output: Node wurzelknoten
		- Visualisierung:
			Wenn überhaupt: Pulsieren der Wurzel
	- Get Tiefe [1]
		- input: Node wurzelknoten
		- output: Int tiefe
			Wenn überhaupt: 
				1. Jedes Element, das betrachtet wird, pulsiert nach und nach
				2. Längster Pfad pulsiert kurz


	- Teilbaum "verschieben" [1] - Kann durch löschen und hinzufügen dargestellt werden
	- Element löschen [2] [3]
		- Weiteres:
			- So oft rotieren bis der zu löschende Knoten ein Blatt ist und dann (Teilbaum) löschen. Mit Get Tiefe kann man vor jeder Rotation prüfen ob links oder rechts besser ist -> nicht sauber effizient machbar?









Operationen an Suchbäumen:

	- Nach Element suchen (also quasi get) [2] [3] [4]
		- input: Value zuSuchenderWert Node wurzelknoten
		- output: Node gesuchterKnoten
		- Weiteres:
			- gibt sowohl iterative als auch rekursive Variante in [4]
			- Aber auf welche Weise? Tiefen- oder Breitensuche? In Suchbaum egal (siehe [4]). Aber gehe ich von Suchbaum aus?
	- Element an bestimmter Stelle hinzufügen [2] [3] [4]
		- input: Node elternknoten , Node neuerKnoten
		- output: - / Boolean
		- Weiteres:
			- in Suchbaum kann man nicht die Stelle bestimmen
	- Element löschen [2] [3] [4]
		- input: Node zuLöschenderKnoten
		- output: - / Boolean
	- Rotieren (?) / Balancieren (?) -> Ich denke Balancieren wäre eine Funktion, die die atomare Funktion "rotieren" nutzt [1] [4 als Transplant?]
		- input: Node zuRotierenderKnoten (dieser und der Elternknoten werden genutzt)
		- output: - / Boolean
	- Get Wurzel (nicht schon automatisch da?) [1]
		- input: -
		- output: Node wurzelknoten
		
	- Get Minimum / Maximum [4]
		- input: Node wurzelknoten
		- output: Node gesuchterKnoten
	- Get Nachfolger (also nächst höherer Wert, arbeitet mit Get Minimum) (nötig?) [4]
		- input: Node startknoten
		- output: Node nachfolgenderKnoten
	- Get Vorgänger (analog zu Nachfolger) [4]
		- input: Node startknoten
		- output: Node vorgehenderKnoten
	
	Auf Knoten:
	- istBlatt
	- getElternknoten
	- hatKind
	- getKind (links, rechts, ggf mehr)
	- getGrad
	
Quellen:
	1 - eigens überlegt
	2 - https://en.wikipedia.org/wiki/Tree_(data_structure)
	3 - https://blog.masaischool.com/tree-data-structure-types-operations-applications/
	4 - Cormen S.292 (312) Abschnitt 12.2 und 12.3





Interessante Stellen aus der Literatur:

	- Algorithmen und Datenstrukturen für Dummies
		- Teil 2 Kapitel 5
	- Cormen
		- S.247 (267) Abschnitt 10.4
		- S.1184 (1204) Abschnitt B.5 (Lösungen für Übungsaufgaben)
		- S.1186 (1208) Abschnitt B.5.2 (Terminologie)
		- S.292 (312) Abschnitt 12.2 und 12.3 (tatsächliche Operationen) 
		- S.316 (336) Abschnitt 13.2 (Pseudocode für Left Rotate für Rot Schwarz Bäume und danach noch mehr Funktionen-Pseudocode)
	
	
	