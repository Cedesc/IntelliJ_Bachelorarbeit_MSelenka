

Teil der Gliederung:
	5 Erweiterung der Darstellung 20 (5)
		5.1 Animationen an den bestehenden Datenstrukturen 20 (4)
			5.1.1 ArrayList
		5.2 Zoomen & Bewegen 24 (1) mehr




Was ich reinbringen kann:
	- bei deletions probleme (noch nicht hinschreiben?)



Kapitel:

5.1 Animationen an den bestehenden Datenstrukturen
	
	// warum Animationen toll sind
	Animationen sind nicht nur ein nettes Gimmick, sondern sie können ungemein zur Verständlichkeit eines Ablaufs beitragen. Denn im Vergleich zum unmittelbaren Auftauchen oder Verschwinden eines Elements, kann der Nutzer bei bspw. einer kurzen Fade-in oder Fade-out Animation das betroffene Element viel schneller identifizieren, da dieses sich durch seine Bewegung vom Rest der Elemente abhebt. Es gibt auch Operationen, bei denen man ohne eine Animation nur sehr schwierig ausmachen kann, was passiert. So zum Beispiel die "insert" oder "delete" Operation der Arraylists, auf die später näher eingegangen wird. In solchen Fällen haben schon kleine Animationen sehr große Wirkung.
	
	// Schwierigkeiten beim Implementieren von Animation
	Jedoch kann es sehr umständlich sein gut funktionierende Animationen zu implementieren. Wie geht man zum Beispiel mit Nutzereingaben um, wenn bisherige Animationen noch nicht abgeschlossen sind? Und ist es für das Programm notwendig zu wissen, wann eine Animation abgeschlossen ist? Wenn ja, wie setzt man dies um? Das sind beispielsweise Fragen, die man im Kopf behalten sollte, möchte man Animationen implementieren. Macht man sich darüber keine Gedanken, so kann es leicht passieren, dass Elemente an Positionen landen, an denen sie nichts zu suchen haben oder dass Animationen zu unsinnigen Zeitpunkten abgespielt werden.
	
	// Eigene Umsetzung
	In unserem Fall, ist es besonders für die Step-by-Step Visualization durchaus wichtig einen korrekten Umgang mit Eingaben, die während laufender Animationen getätigt werden, einzubauen. Zwar können auch bei der Complete Visualization während Animationen Eingaben getätigt werden, diese Beschränkungen sich jedoch auf das Abbrechen oder das Neustarten des Algorithmus. In beiden Fällen sind die derzeitigen Elemente irrelevant und somit kein besonderer Umgang nötig. Sollten noch Funktionen hinzukommen, bei denen dies wichtiger ist, lässt sich das Programm leicht in der updateVisualization-Methode des ExecuteAlgorithmController anpassen, um es mit der Complete Visualization so zu handhaben wie mit der Step-by-Step Visualization. 
	Denn bei der Step-by-Step Visualization springt zunächst die letzt ausgeführte Animation zum Ende, dann wird die nächste gestartet und schließlich diese als "lastTransition" gespeichert, damit man wiederum auf diese in der nächsten Iteration zugreifen kann, um sie ggf. vorzeitig zu beenden. Für den Nutzer bedeutet das, dass eine vorzeitige Eingabe zu keinen Fehlern, sondern nur zu einem vorzeitigen Sprung zum Ende der Animation führt.
	
	// auf die Ordnerstruktur bezogen auf die Animationen eingehen und schreiben wo die erstellt und ausgeführt werden
	So wie es für jede Datenstruktur eine eigene Klasse für die Visualisierung gibt, habe ich ebenso für jede Datenstruktur eine Klasse zum Erstellen der jeweiligen Animationen hinzugefügt. So wird in 
	In der zur Datenstruktur zugehörigen Visualisierungs-Klasse wird am Ende von Befehlen, die eine Animation benötigen, wie bspw. das Einfügen eines Elements, zunächst die visuelle Darstellung konstruiert und dann die zugehörige Animation durch eine separate Klasse erstellt. Diese Abkapselung sorgt für eine bessere Wartbarkeit des Codes, da es sowohl klarer ist, welche Codeabschnitte was bewirken, als auch die Funktionen kürzer und übersichtlicher gehalten werden.
	
	// Sowohl backward als auch forward geht es
	Da man in der Anwendung in der Step-by-Step Visualization sowohl einen Schritt nach vorne als auch einen Schritt zurück gehen kann, stellt sich die Frage, wie man Animationen bei einem Schritt zurück ausführen kann und ob dabei Problematiken auftauchen. Der Code ist jedoch durch das Command-Pattern so geschrieben, dass gar keine Anpassungen getroffen werden mussten um dies zu erreichen. Sowohl vorwärts als auch rückwärts funktionieren die Animationen und das ohne, dass zusätzliche Codezeilen für eine korrekte "Rückwärtsanimation" nötig war.
	


5.1.1 ArrayList
	{noch mehr Animationen eingebaut? Deletions? Get?}
	{erklären warum jetzt arraylist zusätzlich zu array (abgespecktere variante)}
	{deletions macht probleme und get ist noch nicht drin}

	// auf Art der Animationen eingehen, also zb warum ich mich für reinfaden bei insert etc entschieden hab und auch drauf eingehen, was das für eine Besserung für den Nutzer ist
	Bei den Arraylists habe ich drei verschiedene Animationen eingebaut. Eine für das Erstellen einer Arraylists, eine für das Einfügen eines Elements und eine für das Tauschen zweier Elemente innerhalb einer Arraylist. 
	// Erstellen einer Arraylist
	Beim Erstellen einer Arraylist ist es eine simple Fade-in Animation von rechts nach links. Jedoch war es schon zuvor für den Nutzer nicht schwer die neue Struktur auf dem Bildschirm auszumachen.
	// Einfügen eines Elements
	Interessanter ist das Einfügen eines Elements. Während die Animation für das Einfügen am Ende der Arraylist fast genau so simpel wie die Animation für das Erstellen einer Arraylist aussieht und vergleichsweise geringen Mehrwert für den Nutzer hat, so wird der Nutzen deutlich größer, wenn man ein Element zwischen anderen Elementen in einer Arraylist hinzufügt. In diesem Fall werden alle Elemente, die hinter dem neu einzusetzenden Element stehen sollen, während der Fade-in Animation des einzufügenden Elements, einen Platz weiter nach rechts geschoben. Um dies korrekt umzusetzen, habe ich mich eines Tricks bedient, auf den ich näher beim Erklären der Tauschoperation eingehe. Für den Nutzer kann diese Einfügeanimation das Nachvollziehen des Programms deutlich vereinfachen, da dieser direkt sieht, welches Element wo eingefügt wurde.
	// Tauschen zweier Elemente
	Beim Tauschen zweier Elemente bewegen sich die Elemente erst nach oben bzw. unten, dann nach rechts bzw. links und schließlich nach unten bzw. oben, sodass sie dann am jeweils anderen Platz sind. Die Problematik bei der Umsetzung dafür war, dass die Elemente in der dahinterliegenden tatsächlichen Arraylist zum Zeitpunkt, an dem die Animation startet, bereits getauscht wurden und somit auch visuell schon auf dem Platz sind, auf dem sie enden sollten. Um dies aber dennoch korrekt darzustellen, läuft das ganze folgendermaßen ab: Zunächst, werden die Elemente in der dahinterliegenden Arraylist getauscht, dann werden sie allerdings auf visueller Ebene, ohne Animation, nochmals getauscht, um sie dann mit der beschriebenen Animation zu tauschen oder besser gesagt, an den korrekten Platz zurück zu verschieben. Da die ersten beiden Schritte jedoch keine Animation und auch keine merkbare Verzögerung aufweisen, bemerkt der Nutzer nicht, dass die Elemente zum Start der Animation auf visueller Ebene bereits zweimal getauscht wurde. Dies wird hier so oder so ähnlich in jeder Animation genutzt, bei der die Startposition eine andere ist. Besonders aber auch beim Verschieben der Elemente, wenn man ein Element mitten in eine Arraylist einfügt.


5.2 Zoomen & Bewegen
	
	// Zoomen und Bewegen nötig um Übersicht zu halten, wenn die Strukturen sehr groß werden
	Bislang war es nicht möglich die angezeigten Datenstrukturen visuell zu verkleinern oder zu vergrößern. Hatte man nur wenige Elemente war das auch nicht nötig. Jedoch war schon bei den Arraylists ab ein paar dutzend Elementen ein Teil der Datenstruktur nicht zu sehen und man hatte keine Möglichkeit diesen verdeckten Teil ins Sichtfeld zu bringen. Um die Anwendung auch für größere Datensätze gut nutzen zu können, ist es also notwendig dieses Problem zu beheben. 
	Jetzt besteht sowohl die Möglichkeit zu Zoomen, als auch die Möglichkeit die Datenstruktur zu bewegen. Um das vorige Problem zu beheben, dass es in einigen Fällen unmöglich ist, Teile der Datenstruktur zu sehen, hätte für sich schon eine der beiden neuen Funktionalitäten ausgereicht, jedoch bringen beide zusammen eine deutlich einfachere Nutzung der Anwendung. Das Zoomen sorgt dafür, dass man sich bei größeren Strukturen deutlich einfacher einen Gesamtüberblick verschaffen kann, während mit der Möglichkeit zur Bewegung im Feld eine intuitive und nutzerfreundliche Anwendung der Software einhergeht.
	
	// Wie Nutzer es anwenden kann und zoomen möglich relativ zur Mausposition
	Für den Nutzer der Anwendung ist es nun möglich mit dem Mausrad zu zoomen und durch das Halten der Maustaste mit gleichzeitigem Bewegen der Maus die Datenstruktur im Fenster zu bewegen. Beim Zoomen, wird zu der Stelle gezoomt, auf die die Maus gerade zeigt, was für den Nutzer intuitiver zu Bedienen ist, als würde das Fenster immer auf einen festen Punkt zoomen. Beides ist so angepasst, dass es nur funktioniert, wenn die Maus auf einen Punkt innerhalb des jeweiligen Fensters zeigt. Eine gewisse Ausnahme bildet dabei das bewegen mit der gedrückt gehaltenen Maustaste, da sich, sollte die Taste innerhalb des Fensters gedrückt worden sein, die Datenstruktur auch noch weiter bewegen lässt, wenn die Maus außerhalb des Fensters ist. 
	
	// Zoomen und Bewegen führen zu keinen Fehler mit Animationen, wenn es gleichzeitig ausgeführt wird
	Sowohl das Zoomen als auch das Bewegen lassen sich ohne Probleme parallel zu den Animationen ausführen. Selbst bei sehr schnellen Bewegungen, laufen die Animationen mit den richtigen Koordinaten weiter. Durch das parallele Nutzen kann man gegebenenfalls noch besser die Animationen nachverfolgen.
	
	// Bei Auswahl anderes Algorithmus kein Problem
	Weiterhin gibt es auch keine Probleme, wenn mit veränderter Skalierung oder Translation eine andere Datenstruktur oder einen anderen Algorithmus auswählt. Denn wechselt man den Algorithmus oder auch nur die Visualisierung dessen, ist der Zoom und die Translation der zu sehenden Datenstruktur wieder auf den Standardwerten, da bei jeder neuen Auswahl alle der betroffenen Klassen neu erstellt werden und somit keine veralteten Werte beinhalten können.
	
	// wie Zoomen und rumbewegen umgesetzt wurde - von stackoverflow; erklären was ich geändert hab
	Die Grundidee von der konkreten Implementierung dieser Funktionalitäten stammt von hier {https://stackoverflow.com/questions/29506156/javafx-8-zooming-relative-to-mouse-pointer}. Für das Programm passend abgeändert und teils erweitert, findet man den Code in vier Klassen aufgeteilt unter "supportClasses.zooming" und "supportClasses.moving". Beim Zoomen wird durch eine Bindung von den Scale-Properties des Fensters der komplette Inhalt vergrößert oder auch verkleinert. Beim Bewegen kann man sogar einzelne Inhalte des Fenster auswählen, welche bewegt werden sollen. Bislang entspricht dieser ausgewählte Inhalt allerdings immer dem kompletten Inhalt des Fensters. Die Möglichkeit nur einzelne Elemente des Fensters zu bewegen, könnte allerdings eventuell für spätere Funktionalitäten genutzt werden. 
	
	// Weitere Ideen
	Neben der Möglichkeit nur ausgewählte Elemente des Fensters zu bewegen, gibt es noch weitere Funktionalitäten, die in diesem Kontext gut umsetzbar wären. Sehr leicht einzubringen wäre die Möglichkeit auf einen Click den Zoom oder auch die Translation auf den Standard zurückzusetzen. Das wäre jeweils durch eine simple Methode, die den gespeicherten Wert auf den Standardwert zurücksetzt, möglich. Bei der Bewegung könnte sich da als Schwierigkeit herausstellen, da auch die Animationen von den Translationen gebrauch machen, jedoch müsste man, um diesen Konflikt zu umgehen, schlichtweg die durch die Maus getätigten Bewegungen abspeichern und diesen Wert letztlich zurücksetzen anstatt der kompletten Translation des Elements.


5.? Neue Struktur der Architektur (UML & Sequenz Diagramm)
	{
		UML Diagramm überarbeiten. 
		1. Richtige Abhängigkeiten setzen, also die Pfeile, die sind bislang nur provisorisch gleich gesetzt
		2. "ArrayVisualization", "ArrayAnimation", "-arrayAnimation", etc. in "ArrayList..." umbenennen
		3. Ggf altes durchgestrichen rot und das neue grün machen
		4. Verbindung von SceneGestures und NodeGestures zu ExecuteAlgorithmController? Also eine einfache Relation im Sinne von "hat damit zu tun"
		5. fieldDistance von AbstractAnimationCreator löschen
		6. playOneByOne aus TransitionChain löschen (und auch calculateDelaysForCompleteVisualization und startAnimation?)
		7. ZoomPane myScale privat machen?
		8. generell prüfen ob alles so noch up to date ist und keine funktionen zb umbenannt wurden
		9. neu platzieren, sodass man schöne farbige rechtecke machen kann um die einzelnen features bewegung, zoomen und animation abzugrenzen?
	}
	{
		Sequenzdiagramm für Visualisierung wegen Animationen? Und wegen complete visualization?
		Sequenz:
			XYVisualization
				=> wie die animation aufgerufen wird
			controller.ExecuteAlgorithmController
				=> initialize (wegen SceneGestures und NodeGestures um zu sehen, wann diese mit reinspielen)
				   updateVisualization
			ParentViewModel
				=> startCompleteVisualization
		Sequenz-Diagramm in der BA von MS ist auf Seite 36-39
	}

	{Richtige Abbildungsbezeichnungen reinpacken}
	{Richtiger Kapitelverweis reinpacken und auch verlinken (zu dem wie man eine Datenstruktur hinzufügt}
	// Generelles
	Um die strukturellen Erweiterungen und Änderungen der Anwendungsarchitektur übersichtlich aufzuzeigen, liegt mit {Abbildung 1?} ein UML-Diagramm vor. Dieses stellt nicht das komplette Programm dar, sondern nur die neu erstellten Klassen im Bereich der Animationen, Zoomen und Bewegung. Dabei ist alles, was neu hinzugefügt wurde grün markiert und alles, was bereits zuvor vorhanden war, in schwarz. Damit einzelne Klassen nicht durch zu viele, für diese Darstellung unwichtiger, Attribute und Methoden unübersichtlich werden, wurden einige dieser ausgelassen. Dies ist in den Klassen ParentViewModel, ExecuteAlgorithmController und der JavaFX-Klasse Pane der Fall. Abgesehen von der hinzugefügten Datenstruktur Baum und einer Klasse um die Config-Datei einzulesen, hat der Rest der Anwendung ein, im Vergleich zur vorigen Version, unverändertes UML-Diagramm. Auf die genannten Ausnahmen wird später eingegangen.

	{ab erster Erwähnung von "initialize" Code davon zeigen ums schöner zu haben? Oder Sequenzdiagramm?}
	// Bewegen
	Für das Feature der Bewegung innerhalb des Anzeigefensters wurden die Klassen DragContext und NodeGestures hinzugefügt. Dabei ist DragContext nur dafür da um für den Prozess wichtige Werte abzuspeichern, während NodeGestures für das korrekte Ausführen der Bewegung verantwortlich ist. Dafür wird lediglich in initialize() von ExecuteAlgorithmController eine Instanz von NodeGestures erstellt und zum zugehörigen Anzeigefenster als Events hinzugefügt. 
	// Zoomen
	Das Zoomen wird von ZoomPane und SceneGestures ermöglicht. ZoomPane dient dafür als sichtbares Fenster, weshalb es auch von der JavaFX-Klasse Pane erbt. Der tatsächliche Vorgang wird allerdings von der Klasse SceneGestures übernommen. Von SceneGestures wird, ähnlich wie bei NodeGestures, in der initialize-Methode von ExecuteAlgorithmController eine Instanz erstellt und zum Fenster, in dem das ZoomPane liegt, als Event hinzugefügt. 
	// Animation
	Etwas aufwendigere Änderungen waren für die hinzuzufügenden Animationen notwendig. Für jede Datenstruktur, die Animationen bieten soll, wird eine Animationsklasse erstellt und als Attribut in der zugehörigen Visualisierungsklasse abgespeichert. Die jeweiligen Animationen werden in dieser Animationsklasse erstellt. Außerdem erbt sie von AbstractAnimationCreator, um gewisse einheitliche Methoden zu ermöglichen, u.a. das zuweisen einer "leeren Animation", die schlichtweg wartet, bis die Animationszeit vorüber ist. Insgesamt sorgt Abkapselung der Animationen von der Visualisierung für eine besser Lesbarkeit und Wartbarkeit des Programmcodes. Eine weitere Klasse, die für die Animationen hinzugefügt wird ist TransitionChain, welche für leichtere Verwaltung mehrerer Animationen sorgt. Jedes mal wenn eine Animation erstellt wird, wird sie zu TransitionChain hinzugefügt. Soll nun z.B. die Visualisierung beendet werden, können alle Animationen durch einen einzigen Zugriff auf TransitionChain vorzeitig zum Animationsende springen.

	// Klassen, die nicht vom UML Diagramm gezeigt werden
	Es wurden noch weitere Klassen zum Programmcode hinzugefügt, die nicht in {Abbildung 1?} vorzufinden sind. Zum einen ConfigReader, welche allerdings einzig das Auslesen der zusätzlich hinzugefügten Config-Datei übernimmt. Zudem wurden mehrere Dateien zu Bäumen hinzugefügt, wobei es sich hier, zumindest bezüglich der Softwarearchitektur, einfach um eine weitere Datenstruktur handelt. Wie im Allgemeinen eine neue Datenstruktur hinzugefügt werden kann, wie auch die Bäume hinzugefügt wurden, wird in {Kapitel XY} erklärt.	
