

Titel: „Erweiterung der Visualisierungs-Software für Datenstrukturen um Animationen am Beispiel von Bäumen“



Gliederung (neu neu neu):
						X : bereits geschriebenes
						_ : noch nicht geschriebenes
						~ : unsichere sachen
						! : sichere sachen
	! 1 Einleitung
				- grundlegende Einleitung
		!X 1.1 Motivation 
		~_ 1.2 Vergleich von bestehenden ähnlichen Programmen 
		~_ 1.3 Zielsetzung 
		!_ 1.4 Strukturierung des Inhalts der Arbeit 
	! 2 Datenstruktur Baum 
				- theoretische Grundlagen und Nutzung von Bäumen
		!X 2.1 Terminologie 
		!X 2.2 Definition 
		~X 2.3 Verschiedene Speicherungsweisen von Bäumen
		!X 2.4 Atomare Operationen 
		~_ 2.5 Anwendung von Bäumen
			~_ 2.5.1 Bäume im Alltag / Anwendung
			~_ 2.5.2 (spezifische) Algorithmen auf Bäumen / meistgenutzte Algorithmen
			~_ 2.5.3 (spezifische) Unterarten von Bäumen / meistgenutzte Arten
				- Binärbaum
				- Rot-Schwarz-Baum
		!_ 2.6 Zusammenfassung 
	! 3 Änderungen am bestehenden Code
				- Änderungen am Code, die nicht zu den großen Erweiterungen gehören (Animation, Bewegung, Zoomen, Bäume)
		!X 3.1 Refactoring & Kommentare
		!_ 3.2 ArrayList hinzugefügt
		!X 3.3 Komplette Visualisierung gefixt
		!X 3.4 Config Datei
		!_ 3.5 Zusammenfassung
	! 4 Darstellung Baum im Programm 
				- Umsetzung der Bäume
		!X 4.1 Problematik 
		~X 4.2 "Algorithmen" zum testen
		!X 4.3 Algorithmus zum Baum Visualisieren
		!X 4.4 Atomare Funktionen + Art der Abspeicherung
		!_ 4.5 Zusammenfassung
	! 5 Erweiterung um visuelle Features
				- Umsetzung der Animationen, Zoomen und Bewegen
		!X 5.1 Animationen 
			!X 5.1.1 Animationen in ArrayList
			!X 5.1.2 Animationen in Bäumen (ist noch in "4.? Atomare Funktionen + Art der Abspeicherung")
		!X 5.2 Zoomen & Bewegen 
		!X 5.3 Neue Struktur der Architektur (UML & Sequenz Diagramm)
		!_ 5.4 Zusammenfassung
	! 6 Zukünftiger Code
				- Woran man ansetzen kann
		~_ 6.1 Erweiterbarkeit
			!X 6.1.1 Erweiterbarkeit um weitere Datenstruktur
			!X 6.1.2 Erweiterbarkeit um Baumunterarten
			~_ 6.1.3 Erweiterbarkeit um weitere Animationen
		!X 6.2 Bestehende Probleme
		!_ 6.3 Zusammenfassung
	! 7 Zusammenfassung
				- grundlegende Zusammenfassung
		!_ 7.1 Fazit
		!_ 7.2 Ausblick





Gliederung (neu neu):
						X : bereits geschriebenes
						_ : noch nicht geschriebenes
						~ : unsichere sachen
						! : sichere sachen
	! 1 Einleitung
		!_ 1.1 Motivation 
			- Animationen machen dem Nutzer die Sachen leichter verständlich
			- Bäume sind voll wichtig und so
		~_ 1.2 Vergleich von bestehenden ähnlichen Programmen 
		~_ 1.3 Zielsetzung 
		!_ 1.4 Strukturierung des Inhalts der Arbeit 
	! 2 Datenstruktur Baum 
		!X 2.1 Terminologie 
		!X 2.2 Definition 
		~_ 2.3 Eigenschaften 
			~_ 2.3.1 Vorteile
			~_ 2.3.2 Nachteile
		~_ 2.4 Verschiedene Arten von Bäumen 
			~_ 2.4.1 Binärbaum
			~_ 2.4.2 Rot-Schwarz-Bäume ? (weil es besonders ist, dass die gefärbt sind)
			~_ 2.4.3 ...
		!_ 2.5 Zusammenfassung 
		~_ 2.? Bäume im Alltag
	~ 3 Algorithmen auf Bäumen 
		~X 3.1 Verschiedene Speicherungsweisen von Bäumen
		!X 3.2 Atomare Operationen 
		~_ 3.3 (spezifische) Algorithmen auf Bäumen
	! 4 Darstellung Baum im Programm 
		!_ 4.1 Problematik 
		~_ 4.2 balanciert vs unbalanciert 
		~X 4.? "Algorithmen" zum testen
		!X 4.? Algorithmus zum Baum Visualisieren
		!X 4.? Erweiterbarkeit der Bäume
		!X 4.? Atomare Funktionen und ihre Animationen + Art der Abspeicherung
	! 5 Erweiterung der Darstellung 
		!X 5.1 Animationen an den bestehenden Datenstrukturen 
			!X 5.1.1 ArrayList
		!X 5.2 Zoomen & Bewegen 
		!_ 5.? Neue Struktur der Architektur (UML & Sequenz Diagramm)
	! 6 Implementierung 
		~_ 6.1 Ablauf und Organisation
		!X 6.2 Änderungen am bestehenden Code
			~_ - Auch auf Bugfixes im bestehenden Code eingehen
		~_ 6.3 Herausforderungen und Umsetzung 
		!_ 6.4 Zusammenfassung 
		!X 6.? Erweiterbarkeit um weitere Datenstruktur
	! 7 Zusammenfassung
		!_ 7.1 Fazit
		!_ 7.2 Ausblick





Gliederung (neu): (UNVOLLSTÄNDIG! siehe oben)

	1 Einleitung (5)
		1.1 Motivation (2)
			- Animationen machen dem Nutzer die Sachen leichter verständlich
			- Bäume sind voll wichtig und so
		1.2 Vergleich von bestehenden ähnlichen Programmen (1)
		1.3 Zielsetzung (1)
		1.4 Strukturierung des Inhalts der Arbeit (1)

	2 Datenstruktur: Baum (8)
		2.1 Definition (3)
		2.2 Terminologie (1)
		2.3 Verschiedene Arten von Bäumen (2)
			2.3.1 Binärbaum
			2.3.2 ...
		2.4 Eigenschaften (1)
			2.4.1 Vorteile
			2.4.2 Nachteile
		2.5 Zusammenfassung (1)

	5 Erweiterung der Darstellung (5)
		5.1 Animationen an den bestehenden Datenstrukturen (4)
			5.1.1 Arraylists
		5.2 Zoomen & Bewegen (1) mehr

	3 Algorithmen auf Bäumen (4)
		3.1 Atomare Operationen (3)
		3.2 (spezifische) Algorithmen auf Bäumen (1)

	4 Darstellung Baum im Programm (2)
		4.1 Problematik (1)
		4.2 balanciert vs unbalanciert (1)

	6 Implementierung (6) (mehr)
		6.1 Ablauf und Organisation (1)
		6.2 Änderungen am bestehenden Code (2)
		    - Auch auf Bugfixes im bestehenden Code eingehen
		6.3 Herausforderungen und Umsetzung (2)
		6.4 Zusammenfassung (1)

	7 Zusammenfassung (3)
		7.1 Fazit (2)
		7.2 Ausblick (1)
			- wo man jetzt ansetzen könnte: deletion animationen, komplexere atomare befehle beinhaltende befehle einbauen, andere art von bäumen oder generell neue datenstruktur einbauen, automatische get animation, ...

	Literatur 













Alt:
	1 Einleitung 1 (5)
		1.1 Motivation 1 (2)
			- Animationen machen dem Nutzer die Sachen leichter verständlich
			- Bäume sind voll wichtig und so
		1.2 Vergleich von bestehenden ähnlichen Programmen 3 (1)
		1.3 Zielsetzung 4 (1)
		1.4 Strukturierung des Inhalts der Arbeit 5 (1)

	2 Datenstruktur: Baum 6 (8)
		2.1 Definition 6 (3)
		2.2 Terminologie 9 (1)
		2.3 Verschiedene Arten von Bäumen 10 (2)
			2.3.1 Binärbaum
			2.3.2 ...
		2.4 Eigenschaften 12 (1)
			2.4.1 Vorteile
			2.4.2 Nachteile
		2.5 Zusammenfassung 13 (1)

	5 Erweiterung der Darstellung 20 (5)
		5.1 Animationen an den bestehenden Datenstrukturen 20 (4)
			5.1.1 Variablen
			5.1.2 Arraylists
			5.1.3 Liste
		5.2 Zoomen 24 (1) mehr

	3 Algorithmen auf Bäumen 14 (4)
		3.1 Atomare Operationen 14 (3)
			3.1.1 Einfügen
			3.1.2 Löschen
			3.1.3 Rotieren
			3.1.4 ...
		3.2 (spezifische) Algorithmen auf Bäumen 17 (1)

	4 Darstellung Baum im Programm 18 (2)
		4.1 Problematik 18 (1)
		4.2 balanciert vs unbalanciert 19 (1)

	6 Implementierung 25 (6) (mehr)
		6.1 Ablauf und Organisation 25 (1)
		6.2 Änderungen am bestehenden Code 26 (2)
		    - Auch auf Bugfixes im bestehenden Code eingehen
		6.3 Herausforderungen und Umsetzung 28 (2)
		6.4 Zusammenfassung 30 (1)

	7 Zusammenfassung 31 (3)
		7.1 Fazit 31 (2)
		7.2 Ausblick 33 (1)

	Literatur 34











Gliederung (MS BA):
	1 Einleitung
		1.1 Motivation
		1.2 Problemstellung und theoretischer Hintergrund
		1.3 Vergleich von bestehenden ähnlichen Programmen
		1.4 Zielsetzung
		1.5 Strukturierung des Inhalts der Arbeit
	2 Theoretische Grundlagen
		2.1 Algorithmen
		2.2 Datenstrukturen
			2.2.1 Variablen
			2.2.2 Array
			2.2.3 Verkettete Liste
		2.3 Zusammenfassung
	3 Anforderungen
		3.1 Szenarien
			3.1.1 Szenario 1
			3.1.2 Szenario 2
			3.1.3 Szenario 3
		3.2 Nutzeranforderungen
		3.3 Nicht-funktionale Anforderungen
			3.3.1 Produktanforderungen
			3.3.2 Nutzbarkeitsanforderungen
			3.3.3 Effizienzanforderungen
			3.3.4 Leistungsanforderungen
		3.4 Funktionale Anforderungen
		3.5 Zusammenfassung
	4 Architektur
		4.1 Allgemeine Struktur
		4.2 Aufbau und UML-Diagramme
		4.3 Ablauf und Sequenzdiagramme
		4.4 Zusammenfassung
	5 Implementierung
		5.1 Ablauf und Organisation
		5.2 Herausforderungen und Umsetzung
		5.3 Zusammenfassung
	6 Zusammenfassung
		6.1 Fazit
		6.2 Ausblick
	Literatur

