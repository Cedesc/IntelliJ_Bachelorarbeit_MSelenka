

Teil der Gliederung:
	4 Darstellung Baum im Programm 18 (2)
		4.1 Problematik 18 (1)
		4.2 balanciert vs unbalanciert 19 (1)



Was ich reinbringen kann:



Kapitel:

4 Darstellung Baum im Programm


4.? Animationen der atomaren Funktionen


4.? "Algorithmen" zum testen
	
	// TreeCompleteK_nary und TreeRandom
	{TODO Die Namen und Bezeichnung (Klasse, Funktion, whatever) anpassen, je nach dem wie es jetzt heißt oder was es nun ist}
	Um Bäume mit beliebiger Anzahl Knoten leicht zu erzeugen, welche sich besonders für das Austesten des Programms oder geschriebener Algorithmen eignen, wurden zwei Algorithmen hinzugefügt. Der erste ist "TreeCompleteK_nary" mit dem es ermöglicht wird einen k-nären Baum, heißt ein Baum mit Grad k, mit n Knoten zu erzeugen. Dabei kann k, so wie die Anzahl Knoten n, beliebig bestimmt werden. "TreeRandom" ist der zweite Algorithmus. Dieser erstellt einen zufälligen Baum mit n Knoten.


4.? Algorithmus zum Baum visualisieren 
	{Ebenen und Knotennamen in die Grafiken zeichnen?}
	
	// Anders als bei den anderen Visualisierungsklassen
	Die Art der Visualisierung der Bäume ist strukturell anders implementiert als die für die anderen bisherigen Datenstrukturen. Bei den anderen Datenstrukturen werden je nach Befehl die betroffenen Elemente als javafx Knoten erstellt, geändert oder gelöscht und dies in einer Liste von javafx Elementen gespeichert, welche letztlich zusammen gezeichnet werden. Stattdessen gibt es nun einen Befehl um die Koordinaten jedes Knotens zu bestimmen und einen weiteren Befehl, der den vorhandenen Baum mit abgespeicherten Koordinaten in den Knoten, zeichnen kann. Diese Umstellung war nötig, um einen übersichtlichen Baum zu erhalten, da sich die räumliche Anordnung der Knoten des Baums deutlich häufiger als bei den bestehenden Datenstrukturen wie Arrays der Fall ist. 
	
	// Wie die Positionen der Knoten bestimmt werden
	Die Funktion zur Berechnung der Positionen der Knoten geht folgendermaßen vor:
		1. Alle Blätter des Baums auf unterster Ebene mit vorgegebenem Abstand platzieren.
		2. Alle Knoten der nächsthöheren Ebene betrachten und wie folgt verfahren:
			2a. Ist der Knoten ein Blatt, so setze seine y-Koordinate auf die y-Koordinate der derzeitigen Ebene. Die x-Koordinate stimmt bereits, da das Blatt zunächst auf unterster Ebene platziert wurde.
			2b. Ist der Knoten kein Blatt, so bestimme sein mittleres Kind und setze seine x-Koordinate auf die des mittleren Kinds. Hat der Knoten eine gerade Anzahl an Kindern, so gibt es zwei mittlere Kinder und stattdessen wird das Mittel der x-Koordinaten der beiden genommen.
		3. Wiederhole Schritt 2 bis alle Ebenen abgearbeitet wurden.
	Hiermit ist nicht die für den Nutzer sichtbare Visualisierung gemeint, sondern das Berechnen der Positionen der Knoten, welches vor jedem Zeichnen des Baums ausgeführt wird.
	
	// Anhand von Grafiken ausführen
	{TODO Grafiken einfügen und die Beschriftungen richtig setzen}
	Unter "TreeDemo.java" ist in der Anwendung ein Baum zu finden, welcher nun als Beispiel betrachtet wird um den vorangegangenen Algorithmus veranschaulichen zu können. Angenommen es liege nun dieser Baum {TODO Abbildung 1 "4 tree positioning drawn"} im Programm vor und die Knoten hätten noch keine Koordinaten zugewiesen um den Baum vernünftig visualisieren zu können. Wenn nun der Algorithmus zum Positionieren der Knoten aufgerufen wird, wäre nach dem oben beschriebenen ersten Schritt das Zwischenergebnis {TODO Abbildung 2 "4 tree positioning drawn"}, vorausgesetzt man visualisierte die Knoten an dieser Stelle. Alle Blätter des Baums wurden auf der untersten Ebene platziert. Wird daraufhin der zweite Schritt ausgeführt, werden, wie in {TODO Abbildung 3 "4 tree positioning drawn"} erkennbar, die Positionen der Blätter 5, 7 und 10 aktualisiert und die Knoten 6, 8 und 9 genau über ihrem jeweils einzigen Kind platziert. Als nächstes wiederholt sich Schritt zwei, wodurch nun die zweite Ebene betrachtet wird und somit auch die Position von Blatt 4 aktualisiert wird. Weiterhin werden Knoten 1, 2 und 3 eingefügt. Während Knoten 3 nur ein Kind hat und deswegen genau über eben diesem platziert wird, ist das bei Knoten 1 und 2 anders. Knoten 1 wird genau über dem mittleren Kind, also Knoten 6 platziert. Die Positionen der Knoten 5 und 7 werden nicht in die Berechnung mit einbezogen. Knoten 2 hat zwei mittlere Kinder, wodurch die x-Koordinate von Knoten 2 genau zwischen diesen platziert wird. Im dritten und damit auch letzten Aufruf von Schritt zwei wird die erste Ebene betrachtet und der Wurzelknoten hinzugefügt ({TODO Abbildung 4 "4 tree positioning drawn"}). Da dieser eine gerade Anzahl an Kindknoten hat, werden nur die mittleren beiden, Knoten 2 und 3, betrachtet um die x-Koordinate der Wurzel zu berechnen. 


4.? Erweiterbarkeit der Bäume
	
	{TODO welches Kapitel zeigt auf wie man eine Datenstruktur hinzufügen kann?}
	Es gibt viele verschiedene Arten von Bäumen mit verschiedenen Anforderungen und Eigenschaften. Beispielweise gibt es die sogenannten Rot-Schwarz-Bäume, bei denen, je nach Autor, jeder Knoten [1] oder jede Kante [2] entweder rot oder schwarz gefärbt ist. Um dies mit der Anwendung darzustellen, wäre es derzeit noch nötig entweder das vorhandene abzuändern oder eine neue Datenstruktur dafür einzufügen. Entscheidet man sich für letzteres, so müsste man zwar einige Dateien abändern und hinzufügen, so wie in Kapitel 6.? beschrieben, wobei das meiste von den bereits vorhandenen Bäumen adaptierbar ist. Um leicht Knoten zu erstellen, die rot oder schwarz einfärbbar sind, kann man eine neu erstellte Klasse für eben diese von den bestehenden Knoten erben lassen und noch das Attribut Farbe hinzufügen. Dabei ist es nicht wichtig, ob die Kanten oder die Knoten gefärbt werden sollen, denn die Kanten zu färben würde auf das gleiche Hinauskommen. Durch die Eigenschaften, dass jeder Kindknoten genau ein Elternteil hat, der Baum verbunden sein muss und keine doppelten Verbindungen bestehen, hat jeder Knoten, außer der Wurzel, genau eine Kante hat, die auf den Elternknoten verweist. Da jede Kante immer einen Eltern- mit einem Kindknoten verbindet, sind alle Kanten abgedeckt, wenn man das zu speichernde Attribut für die Kante schlichtweg im verbundenen Kindknoten speichert. Eine Ausnahme, die beachtet werden muss, bildet dabei die Wurzel. Durch diese Eigenschaften kann man den bestehenden Code durch Vererbung gut für weitere Bäume erweitern.
	
	[1] Cormen Seite 311 (331) Kapitel 13
	[2] Ottmann Seite 350 (369)


4.? Atomaren Funktionen und ihre Animationen + Art der Abspeicherung (linkes-Kind-, rechter-Bruder-Darstellung)
	
	// Atomaren Funktionen
	Die in {TODO richtiges Kapitel} Kapitel 3.2 aufgezählten vier atomaren Funktionen (Hinzufügen eines Blatts, Löschen eines Blatts, Elternknoten eines Knotens ändern, Wert eines Knotens ändern) wurden als Methoden implementiert. Diese Methoden können alle hier relevanten Funktionsweisen nachbilden. Genauer aufgezeigt ist dies im zuvor bereits genannten Kapitel {TODO richtiges Kapitel} 3.2. In der Anwendung selbst müssen zwar das Erstellen eines Baums und das Löschen eines Baums eigene Methoden der Klasse mit eigenen Animationen sein, in der Theorie würden sich diese aber auch durch das Hinzufügen und Löschen eines Blatts darstellen lassen können.
	
	// Animationen der atomaren Funktionen
	Da es sich hier um atomare Funktionen handelt, werden ihre Animationen wahrscheinlich am häufigsten abgespielt. Sogar ausschließlich, angenommen man stellt alle Funktionen mit diesen Methoden dar und behält dabei die Animationen dieser bei. Daher lohnt es sich einen genaueren Blick auf diese spezifischen Animationen zu werfen. 
	Das Hinzufügen und das Löschen eines Blatts haben eine simple Fade-In- beziehungsweise Fade-Out-Animation. Nachzuvollziehen wo im Baum ein Blatt hinzugefügt oder entfernt wurde, sollte sich ohne Animation nicht als schwer für den Nutzer herausstellen. Dennoch wird dies mit den Animationen weiter erleichtert. Besonders die Fade-Out-Animation beim Löschen ist noch aus einem weiteren Aspekt hilfreich. Der Nutzer sieht welchen Wert und welchen Index der Knoten hatte, bevor er entfernt wurde.
	Eine gute, nachvollziehbare Animation für das Ändern eines Elternknotens zu finden ist komplexer, aber gleichzeitig für die Verständlichkeit wichtiger. Um die neue Platzierung des Kindknotens genau aufzuzeigen, wird zunächst die Kante zwischen dem alten Elternknoten und dem Kindknoten entfernt, dann der Kindknoten, mit ggf. seinen Kindknoten unter dem neuen Elternknoten platziert und dann mit einer Kante verbunden. Diese direkte Bewegung zum Zielort hat den Nachteil, dass sich ein Teilbaum durch den kompletten Baum bewegt, was zu unschönen Überlagerungen führen kann. Dieser Nachteil ist allerdings vernachlässigbar, da die Alternativen schlechtere Nachvollziehbarkeit oder komplizierteren Code, bis hin zu große Umstrukturierungen des vorhandenen Codes, mit sich führen würden.
	Auch für das Ändern des Werts eines Knotens wurde eine Animation hinzugefügt. Dabei handelt es sich allerdings um eine simple Fade-Out- gefolgt von einer Fade-In-Animation. Hier greifen die gleichen Vorteile wie bei den Animation für die ersten beiden Methoden.
	
	// "linkes-Kind-, rechter-Bruder-Darstellung" genutzt
	Es ist zu beachten, dass die Bäume nach dem Prinzip der "linkes-Kind-, rechter-Bruder-Darstellung" implementiert wurden [1]. Dies kann zu unintuitiveren Abläufen innerhalb einiger Methoden führen, dafür wird aber auch eine unbegrenzte Anzahl an Kindknoten pro Elternknoten ermöglicht. In {TODO richtiges Kapitel} Kapitel 3.3 ist diese Art der Darstellung des Baums deutlicher beschrieben.
	
	[1] Cormen Seite 248
